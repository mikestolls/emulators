0x200   0x22F6  CALL    0x2F6           # 2NNN: call subroutine at addr NNN
0x202   0x6B0C  LOAD    $12,r11         # 6XNN: put NN into X register
0x204   0x6C3F  LOAD    $63,r12         # 6XNN: put NN into X register
0x206   0x6D0C  LOAD    $12,r13         # 6XNN: put NN into X register
0x208   0xA2EA  LOADI   $746            # ANNN: load NNN to register I
0x20A   0xDAB6  DRAW    r10,r11,$6      # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x20C   0xDCD6  DRAW    r12,r13,$6      # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x20E   0x6E00  LOAD    $0,r14          # 6XNN: put NN into X register
0x210   0x22D4  CALL    0x2D4           # 2NNN: call subroutine at addr NNN
0x212   0x6603  LOAD    $3,r6           # 6XNN: put NN into X register
0x214   0x6802  LOAD    $2,r8           # 6XNN: put NN into X register
0x216   0x6060  LOAD    $96,r0          # 6XNN: put NN into X register
0x218   0xF015  MOVED   r0              # FX15: set delay timer to X
0x21A   0xF007  MOVED   r0              # FX07: set X to delay timer
0x21C   0x3000  SKE     r0,$0           # 3XNN: skip next instruction if X register == NN
0x21E   0x121A  JUMP    0x21A           # 1NNN: set program counter to NNN
0x220   0xC717  RAND    $23,r7          # CXNN: set X to rand(0 - 255) & NN
0x222   0x7708  ADD     $8,r7           # 7XNN: adds NN to the value of register X
0x224   0x69FF  LOAD    $255,r9         # 6XNN: put NN into X register
0x226   0xA2F0  LOADI   $752            # ANNN: load NNN to register I
0x228   0xD671  DRAW    r6,r7,$1        # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x22A   0xA2EA  LOADI   $746            # ANNN: load NNN to register I
0x22C   0xDAB6  DRAW    r10,r11,$6      # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x22E   0xDCD6  DRAW    r12,r13,$6      # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x230   0x6001  LOAD    $1,r0           # 6XNN: put NN into X register
0x232   0xE0A1  SNKEY   r0              # EXA1: skip next instruction if key[X] is not pressed
0x234   0x7BFE  ADD     $254,r11        # 7XNN: adds NN to the value of register X
0x236   0x6004  LOAD    $4,r0           # 6XNN: put NN into X register
0x238   0xE0A1  SNKEY   r0              # EXA1: skip next instruction if key[X] is not pressed
0x23A   0x7B02  ADD     $2,r11          # 7XNN: adds NN to the value of register X
0x23C   0x601F  LOAD    $31,r0          # 6XNN: put NN into X register
0x23E   0x8B02  AND     r0,r11          # 8XY2: AND X and Y and store in X
0x240   0xDAB6  DRAW    r10,r11,$6      # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x242   0x600C  LOAD    $12,r0          # 6XNN: put NN into X register
0x244   0xE0A1  SNKEY   r0              # EXA1: skip next instruction if key[X] is not pressed
0x246   0x7DFE  ADD     $254,r13        # 7XNN: adds NN to the value of register X
0x248   0x600D  LOAD    $13,r0          # 6XNN: put NN into X register
0x24A   0xE0A1  SNKEY   r0              # EXA1: skip next instruction if key[X] is not pressed
0x24C   0x7D02  ADD     $2,r13          # 7XNN: adds NN to the value of register X
0x24E   0x601F  LOAD    $31,r0          # 6XNN: put NN into X register
0x250   0x8D02  AND     r0,r13          # 8XY2: AND X and Y and store in X
0x252   0xDCD6  DRAW    r12,r13,$6      # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x254   0xA2F0  LOADI   $752            # ANNN: load NNN to register I
0x256   0xD671  DRAW    r6,r7,$1        # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x258   0x8684  ADD     r8,r6           # 8XY4: ADD X and Y and store in X. set carry flag if > 255
0x25A   0x8794  ADD     r9,r7           # 8XY4: ADD X and Y and store in X. set carry flag if > 255
0x25C   0x603F  LOAD    $63,r0          # 6XNN: put NN into X register
0x25E   0x8602  AND     r0,r6           # 8XY2: AND X and Y and store in X
0x260   0x611F  LOAD    $31,r1          # 6XNN: put NN into X register
0x262   0x8712  AND     r1,r7           # 8XY2: AND X and Y and store in X
0x264   0x4600  SKNE    r6,$0           # 4XNN: skip next instruction if X register != NN
0x266   0x1278  JUMP    0x278           # 1NNN: set program counter to NNN
0x268   0x463F  SKNE    r6,$63          # 4XNN: skip next instruction if X register != NN
0x26A   0x1282  JUMP    0x282           # 1NNN: set program counter to NNN
0x26C   0x471F  SKNE    r7,$31          # 4XNN: skip next instruction if X register != NN
0x26E   0x69FF  LOAD    $255,r9         # 6XNN: put NN into X register
0x270   0x4700  SKNE    r7,$0           # 4XNN: skip next instruction if X register != NN
0x272   0x6901  LOAD    $1,r9           # 6XNN: put NN into X register
0x274   0xD671  DRAW    r6,r7,$1        # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x276   0x122A  JUMP    0x22A           # 1NNN: set program counter to NNN
0x278   0x6802  LOAD    $2,r8           # 6XNN: put NN into X register
0x27A   0x6301  LOAD    $1,r3           # 6XNN: put NN into X register
0x27C   0x8070  MOVE    r7,r0           # 8XY0: stores value of register Y into register X
0x27E   0x80B5  SUB     r11,r0          # 8XY5: SUB Y from X and store in X. set carry flag to 0 if borrow, 1 if not
0x280   0x128A  JUMP    0x28A           # 1NNN: set program counter to NNN
0x282   0x68FE  LOAD    $254,r8         # 6XNN: put NN into X register
0x284   0x630A  LOAD    $10,r3          # 6XNN: put NN into X register
0x286   0x8070  MOVE    r7,r0           # 8XY0: stores value of register Y into register X
0x288   0x80D5  SUB     r13,r0          # 8XY5: SUB Y from X and store in X. set carry flag to 0 if borrow, 1 if not
0x28A   0x3F01  SKE     r15,$1          # 3XNN: skip next instruction if X register == NN
0x28C   0x12A2  JUMP    0x2A2           # 1NNN: set program counter to NNN
0x28E   0x6102  LOAD    $2,r1           # 6XNN: put NN into X register
0x290   0x8015  SUB     r1,r0           # 8XY5: SUB Y from X and store in X. set carry flag to 0 if borrow, 1 if not
0x292   0x3F01  SKE     r15,$1          # 3XNN: skip next instruction if X register == NN
0x294   0x12BA  JUMP    0x2BA           # 1NNN: set program counter to NNN
0x296   0x8015  SUB     r1,r0           # 8XY5: SUB Y from X and store in X. set carry flag to 0 if borrow, 1 if not
0x298   0x3F01  SKE     r15,$1          # 3XNN: skip next instruction if X register == NN
0x29A   0x12C8  JUMP    0x2C8           # 1NNN: set program counter to NNN
0x29C   0x8015  SUB     r1,r0           # 8XY5: SUB Y from X and store in X. set carry flag to 0 if borrow, 1 if not
0x29E   0x3F01  SKE     r15,$1          # 3XNN: skip next instruction if X register == NN
0x2A0   0x12C2  JUMP    0x2C2           # 1NNN: set program counter to NNN
0x2A2   0x6020  LOAD    $32,r0          # 6XNN: put NN into X register
0x2A4   0xF018  MOVES   r0              # FX18: set sound timer to X
0x2A6   0x22D4  CALL    0x2D4           # 2NNN: call subroutine at addr NNN
0x2A8   0x8E34  ADD     r3,r14          # 8XY4: ADD X and Y and store in X. set carry flag if > 255
0x2AA   0x22D4  CALL    0x2D4           # 2NNN: call subroutine at addr NNN
0x2AC   0x663E  LOAD    $62,r6          # 6XNN: put NN into X register
0x2AE   0x3301  SKE     r3,$1           # 3XNN: skip next instruction if X register == NN
0x2B0   0x6603  LOAD    $3,r6           # 6XNN: put NN into X register
0x2B2   0x68FE  LOAD    $254,r8         # 6XNN: put NN into X register
0x2B4   0x3301  SKE     r3,$1           # 3XNN: skip next instruction if X register == NN
0x2B6   0x6802  LOAD    $2,r8           # 6XNN: put NN into X register
0x2B8   0x1216  JUMP    0x216           # 1NNN: set program counter to NNN
0x2BA   0x79FF  ADD     $255,r9         # 7XNN: adds NN to the value of register X
0x2BC   0x49FE  SKNE    r9,$254         # 4XNN: skip next instruction if X register != NN
0x2BE   0x69FF  LOAD    $255,r9         # 6XNN: put NN into X register
0x2C0   0x12C8  JUMP    0x2C8           # 1NNN: set program counter to NNN
0x2C2   0x7901  ADD     $1,r9           # 7XNN: adds NN to the value of register X
0x2C4   0x4902  SKNE    r9,$2           # 4XNN: skip next instruction if X register != NN
0x2C6   0x6901  LOAD    $1,r9           # 6XNN: put NN into X register
0x2C8   0x6004  LOAD    $4,r0           # 6XNN: put NN into X register
0x2CA   0xF018  MOVES   r0              # FX18: set sound timer to X
0x2CC   0x7601  ADD     $1,r6           # 7XNN: adds NN to the value of register X
0x2CE   0x4640  SKNE    r6,$64          # 4XNN: skip next instruction if X register != NN
0x2D0   0x76FE  ADD     $254,r6         # 7XNN: adds NN to the value of register X
0x2D2   0x126C  JUMP    0x26C           # 1NNN: set program counter to NNN
0x2D4   0xA2F2  LOADI   $754            # ANNN: load NNN to register I
0x2D6   0xFE33  BCD     r14             # FX33: store binary decimals of X into I, I+1, I+2
0x2D8   0xF265  READ    r2              # FX65: store memory starting at I into 0 to X
0x2DA   0xF129  LDSPR   r1              # FX29: set I to the memory addr of font character in X
0x2DC   0x6414  LOAD    $20,r4          # 6XNN: put NN into X register
0x2DE   0x6500  LOAD    $0,r5           # 6XNN: put NN into X register
0x2E0   0xD455  DRAW    r4,r5,$5        # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x2E2   0x7415  ADD     $21,r4          # 7XNN: adds NN to the value of register X
0x2E4   0xF229  LDSPR   r2              # FX29: set I to the memory addr of font character in X
0x2E6   0xD455  DRAW    r4,r5,$5        # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x2E8   0x00EE  RTS                     # 00EE: returns from subroutine
0x2EA   0x8080  MOVE    r8,r0           # 8XY0: stores value of register Y into register X
0x2EC   0x8080  MOVE    r8,r0           # 8XY0: stores value of register Y into register X
0x2EE   0x8080  MOVE    r8,r0           # 8XY0: stores value of register Y into register X
0x2F0   0x8000  MOVE    r0,r0           # 8XY0: stores value of register Y into register X
0x2F2   0x0000  CLR                     # 00E0: clears the screen
0x2F4   0x0000  CLR                     # 00E0: clears the screen
0x2F6   0x6B20  LOAD    $32,r11         # 6XNN: put NN into X register
0x2F8   0x6C00  LOAD    $0,r12          # 6XNN: put NN into X register
0x2FA   0xA2EA  LOADI   $746            # ANNN: load NNN to register I
0x2FC   0xDBC1  DRAW    r11,r12,$1      # DXYN: Display n-byte sprite starting at memory location I at (Vx, Vy), set VF = collision
0x2FE   0x7C01  ADD     $1,r12          # 7XNN: adds NN to the value of register X
0x300   0x3C20  SKE     r12,$32         # 3XNN: skip next instruction if X register == NN
0x302   0x12FC  JUMP    0x2FC           # 1NNN: set program counter to NNN
0x304   0x6A00  LOAD    $0,r10          # 6XNN: put NN into X register
0x306   0x00EE  RTS                     # 00EE: returns from subroutine
